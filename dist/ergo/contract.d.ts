export declare const min_erg_value = "1000000";
export declare const DIGITAL_PUBLIC_GOOD_SCRIPT = "\n/**\n* ===================================================================================\n* Contract for a \"Digital Public Good\" (used for Type NFTs)\n* ===================================================================================\n*\n* PURPOSE:\n* To protect a box containing an NFT and its metadata in registers, ensuring\n* the information serves as a permanent and immutable standard for the ecosystem.\n*\n* SPENDING RULES:\n* 1. Anyone can spend this box (no signature required).\n* 2. Spending is only valid if a single output box is created that is an\n* exact replica of the input, except for its ERG value, which must\n* be greater than or equal. This allows for top-ups to pay storage rent.\n*\n* -----------------------------------------------------------------------------------\n* R4: Coll[Byte] -> typeName\n* - Purpose: Human-readable name of the type (e.g., \"Web URL\").\n*\n* R5: Coll[Byte] -> description\n* - Purpose: Brief description of the type's use and purpose.\n*\n* R6: Coll[Byte] -> schemaURI\n* - Purpose: URI to a schema (JSON Schema, IPFS) that defines the data\n* structure for proofs that use this type.\n*\n* R7: Boolean -> isReputationProof\n* - Purpose: Boolean value that is true if this type is used for\n* a reputation proof, and false otherwise.\n*\n* R8: (Empty) -> reserved_1\n* - Purpose: Reserved for future extensions.\n*\n* R9: (Empty) -> reserved_2\n* - Purpose: Reserved for future extensions.\n* -----------------------------------------------------------------------------------\n*/\n{\n  // Filters the outputs to find the one containing the same NFT as this box (SELF).\n  val successorOutputs = OUTPUTS.filter { (box: Box) =>\n    box.tokens.size > 0 && box.tokens(0)._1 == SELF.tokens(0)._1\n  }\n\n  // Validates that exactly one successor box has been found.\n  if (successorOutputs.size == 1) {\n    val successor = successorOutputs(0)\n\n    // Defines the immutability conditions.\n    // Each register from R4 to R9 must be checked individually.\n    // R7 now checks for a Boolean instead of a Coll[Byte].\n    val registersAreImmutable = (\n      successor.R4[Coll[Byte]] == SELF.R4[Coll[Byte]] &&\n      successor.R5[Coll[Byte]] == SELF.R5[Coll[Byte]] &&\n      successor.R6[Coll[Byte]] == SELF.R6[Coll[Byte]] &&\n      successor.R7[Boolean] == SELF.R7[Boolean] &&\n      successor.R8[Coll[Byte]] == SELF.R8[Coll[Byte]] &&\n      successor.R9[Coll[Byte]] == SELF.R9[Coll[Byte]]\n    )\n\n    val dataIsImmutable = (\n      // The protection script cannot change.\n      successor.propositionBytes == SELF.propositionBytes &&\n      // The NFT token must be preserved identically.\n      successor.tokens(0) == SELF.tokens(0) &&\n      // Registers R4-R9 must be identical.\n      registersAreImmutable\n    )\n\n    // The ERG value of the output must be greater than or equal to the input's.\n    val canOnlyAddErgs = successor.value >= SELF.value\n\n    // The transaction is valid if the immutability and value conditions are met.\n    sigmaProp(dataIsImmutable && canOnlyAddErgs)\n\n  } else {\n    // Fails if exactly one successor is not found, to prevent\n    // the destruction or duplication of the NFT.\n    sigmaProp(false)\n  }\n}\n";
export declare const digital_public_good_ergo_tree: string;
export declare const digital_public_good_contract_hash: string;
export declare const REPUTATION_PROOF_SCRIPT: string;
export declare const ergo_tree_address: string;
export declare const ergo_tree_hash: string;
export declare const ergo_tree: string;
